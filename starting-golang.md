# Chapter 1

# Goの特徴

- ネイティブコードへのコンパイル

- マルチプラットフォームで動作

- OSへの非依存

- ガベージコレクター

- 並行処理（ゴルーチン goroutine）

## 環境変数の設定

https://qiita.com/fuwamaki/items/3d8af42cf7abee760a81

PATH

環境変数PATHに、goがインストールされている場所を指定する

/usr/local/go/bin/goにインストールされているとすると、ここにある(bin内にある)コマンドを実行するためには

/usr/local/go/bin/go version

のように実行する必要がある。

それを省くために

export PATH="/usr/local/go/bin:$PATH"

とすることで、bin内に入っているコマンドを

go version

と実行できるようになる


```
export GOPATH=$HOME/go
export PATH="$GOROOT/bin:$PATH"
export PATH="$GOPATH/bin:$PATH"
```

### GOPATH

Goは外部のライブラリが格納されているディレクトリの場所を知るために、GOPATHを利用する。

この環境変数が未設定の場合は、一部のGoのツールを起動できない。

とりあえず、ここでは、「空のディレクトリを作ってその場所をGOPATHとして設定する必要がある」ということを理解する。

（自分の設定は/Users/ythe/go）

## SCMとの連携

ソースコードの履歴管理に何らかの「SCM (Source Code Management)ツール」の利用を前提にするのはもはや常識。

Goでソフトウェア開発を行う場合には、Gitが必要になる機会が多々ある



# Chapter 2 プログラムの構成と実行

## Goプログラムの実行

`go run [ファイルパス]`

## package

package main

Goでは、変数や関数といったプログラムのすべての要素は、何らかの「パッケージ」に属する。

必然的にプログラムはパッケージの宣言から始まる。

「package main」という宣言によって、このファイルがmainパッケージに関するプログラムであることを示す。

また、Goには、「1つのファイルに記述できるのは単一のパッケージについてのみ」という原則がある。

## import

次に続くのが、ファイル内のプログラムで使用するパッケージを指定するためのimport宣言。

Goに付属する有用なライブラリは、全て固有の名前を持つパッケージとして提供されている。

特に必要なパッケージがなければimport宣言は省略可能。

（逆に、参照されないパッケージをimportするとコンパイルエラー）

裏技的な回避策として、import文のパッケージ名の左側に、_を補うと、コンパイルエラーは発生しないようになる。

```
import (
  _ "fmt" // 参照されないパッケージを取り込む書き方
)
```

_を補ったパッケージについては、使用しているかどうかのチェックはされないため、一時的にコンパイラによるチェックを避けるために使用することができる。しかし、これはコンパイラによるチェックを無視するために用意された機能ではなく、参照されていないパッケージを強制的にプログラム内に組み込むための機能

## エントリーポイント

最後のブロックは、プログラムの本体に当たる関数mainの定義。Goのプログラムのエントリーポイント（実行が開始される場所）は、mainパッケージの中に定義された関数mainであると定められている。

## プログラムのビルド

### go build

go buildコマンドは、オプションで与えたGoファイルを実行ファイル形式にコンパイルする。

`go build -o hello hello.go`

-oオプションを使用して、出力する実行ファイルのファイル名を指定できる。

ビルドに成功すると、Goプログラムと同じディレクトリ内に、実行ファイルhelloが生成される。

ビルドで生成されたファイルを実行すると、go runで実行した場合と同様の出力が得られる。

`. /hello`

### goの実行ファイル

コンパイルされた結果の実行ファイルは、ソースコードのファイルに比べて大きいものになっている。これは、GoはOSによって提供される標準的なライブラリにすら依存しない。

このため、Goのランタイム本体と、指定したパッケージの機能全てが実行ファイルの中に組み込まれることになる。

### パッケージと構成

Goでは、パッケージを単位として、ソースコードをファイルやディレクトリに分割し、プログラムを作成する。

#### プログラムの構成

同じパッケージを定義するファイルを、同じディレクトリにまとめる

すべておなじanimalsパッケージについて定義されているファイルが複数あるなら、1つのパッケージを複数のソースコードを使っ定義することもできる。

```
package animals

func ElephantFeed() string {
	return "Grass"
}

func MonkeyFeed() string {
	return "Banana"
}

func RabbitFeed() string {
	return "Carrot"
}
```

管理しやすく、見通しの良い形であれば、複数ファイルに分けても、同一ファイルにまとめてもOK

---

[note]

ローカルで作成したモジュールをimportする場合は、相対パスではできない。

そのため、go.modを作成する必要がある。

`go mod init animals`

下記参照

https://pod.hatenablog.com/entry/2018/12/26/074944

https://qiita.com/hnishi/items/a9217249d7832ed2c035

---

Goでは通常パッケージ名がそのままディレクトリ名となるようにファイル構成を行う。

```
zoo
 |
 |---- animals
 |        |
 |        |---- elephant.go
 |        |---- monkey.go
 |        |---- rabit.go
 |
 |---- main.go
```

### プログラムのビルド

go run main.goによる実行に成功したので、次はビルドを行う。

main.goファイルのあるディレクトリの位置で、特にオプション等を指定せずに、go buildコマンドを実行する。

ビルドに成功すると、実行ファイルzooが生成される。

特に事項ファイルの名前を指定していない場合は、カレントディレクトリの名前を実行ファイルの名前に転用する。

（ただし、go.modがある場合は別っぽい

go.modの一行目、`module ahan`（ローカルパッケージを使う側のモジュール名）が実行ファイルの名前になる

）

また、ビルド対象のgoファイルを指定しなくても、自動的にカレントディレクトリ内の.goという拡張子が与えられたファイルをビルド対象として読み込む。

更に、animalsというパッケージについても、main.go内のimport文から自動的にビルド対象として読み込まれる。

### mainパッケージの分割

animalsパッケージが複数のGoファイルによって構成されているように、mainパッケージも分割可能。

```
zoo
 |
 |---- animals
 |        |
 |        |---- elephant.go
 |        |---- monkey.go
 |        |---- rabit.go
 |
 |---- app.go
 |---- main.go
```

そして、main.go内の関数mainに、定義した関数を呼び出す処理を追加する。

同じmainパッケージに定義された関数なので、main.AppName()のようなパッケージ指定が不要。

```
package main

import {
	"fmt"

	"./animals"
)

func main() {
	fmt.Println(AppName()) /* 関数AppNameの呼び出し */

	fmt.Println(animals.ElephantFeed())
	fmt.Println(animals.MonkeyFeed())
	fmt.Println(animals.RabbitFeed())
}
```

しかし、これでgo runするとエラー発生。

AppNameという関数が未定義だと指摘される。

go runコマンドは、オプションで指定されたmain.goのみを実行対象として選択し、app.goの存在を無視する。

app.goを含めて実行させるには、mainパッケージを定義しているGoファイルをすべて列挙するか、*.goのようにワイルドカードを使って指定する必要がある。

go run main.go app.go

go run *.go

---

ただし、go buildは、app.goを追加した後でも問題なくビルドできる。

go buildは、とくにビルド対象の指定がない場合には、カレントディレクトリ内のGoファイルを「すべて」ビルド対象に含める。

go buildはビルド対象の指定がない場合は、「go build *.go」の動作をする。


